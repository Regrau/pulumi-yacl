// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AlbBackendGroupGrpcBackend {
    healthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheck;
    loadBalancingConfig?: outputs.AlbBackendGroupGrpcBackendLoadBalancingConfig;
    name: string;
    port?: number;
    targetGroupIds: string[];
    tls?: outputs.AlbBackendGroupGrpcBackendTls;
    weight?: number;
}

export interface AlbBackendGroupGrpcBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupGrpcBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupGrpcBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupGrpcBackendTlsValidationContext;
}

export interface AlbBackendGroupGrpcBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbBackendGroupHttpBackend {
    healthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheck;
    http2?: boolean;
    loadBalancingConfig?: outputs.AlbBackendGroupHttpBackendLoadBalancingConfig;
    name: string;
    port?: number;
    storageBucket?: string;
    targetGroupIds?: string[];
    tls?: outputs.AlbBackendGroupHttpBackendTls;
    weight?: number;
}

export interface AlbBackendGroupHttpBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupHttpBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupHttpBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupHttpBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupHttpBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupHttpBackendTlsValidationContext;
}

export interface AlbBackendGroupHttpBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbBackendGroupSessionAffinity {
    connection?: outputs.AlbBackendGroupSessionAffinityConnection;
    cookie?: outputs.AlbBackendGroupSessionAffinityCookie;
    header?: outputs.AlbBackendGroupSessionAffinityHeader;
}

export interface AlbBackendGroupSessionAffinityConnection {
    sourceIp?: boolean;
}

export interface AlbBackendGroupSessionAffinityCookie {
    name: string;
    ttl?: string;
}

export interface AlbBackendGroupSessionAffinityHeader {
    headerName: string;
}

export interface AlbBackendGroupStreamBackend {
    enableProxyProtocol?: boolean;
    healthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheck;
    loadBalancingConfig?: outputs.AlbBackendGroupStreamBackendLoadBalancingConfig;
    name: string;
    port?: number;
    targetGroupIds: string[];
    tls?: outputs.AlbBackendGroupStreamBackendTls;
    weight?: number;
}

export interface AlbBackendGroupStreamBackendHealthcheck {
    grpcHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck;
    healthcheckPort?: number;
    healthyThreshold?: number;
    httpHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent?: number;
    streamHealthcheck?: outputs.AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold?: number;
}

export interface AlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck {
    serviceName?: string;
}

export interface AlbBackendGroupStreamBackendHealthcheckHttpHealthcheck {
    host?: string;
    http2?: boolean;
    path: string;
}

export interface AlbBackendGroupStreamBackendHealthcheckStreamHealthcheck {
    receive?: string;
    send?: string;
}

export interface AlbBackendGroupStreamBackendLoadBalancingConfig {
    localityAwareRoutingPercent?: number;
    mode?: string;
    panicThreshold?: number;
    strictLocality?: boolean;
}

export interface AlbBackendGroupStreamBackendTls {
    sni?: string;
    validationContext?: outputs.AlbBackendGroupStreamBackendTlsValidationContext;
}

export interface AlbBackendGroupStreamBackendTlsValidationContext {
    trustedCaBytes?: string;
    trustedCaId?: string;
}

export interface AlbHttpRouterRouteOptions {
    rbac?: outputs.AlbHttpRouterRouteOptionsRbac;
}

export interface AlbHttpRouterRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbHttpRouterRouteOptionsRbacPrincipal[];
}

export interface AlbHttpRouterRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbHttpRouterRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
}

export interface AlbLoadBalancerAllocationPolicy {
    locations: outputs.AlbLoadBalancerAllocationPolicyLocation[];
}

export interface AlbLoadBalancerAllocationPolicyLocation {
    disableTraffic?: boolean;
    subnetId: string;
    zoneId: string;
}

export interface AlbLoadBalancerListener {
    endpoints?: outputs.AlbLoadBalancerListenerEndpoint[];
    http?: outputs.AlbLoadBalancerListenerHttp;
    name: string;
    stream?: outputs.AlbLoadBalancerListenerStream;
    tls?: outputs.AlbLoadBalancerListenerTls;
}

export interface AlbLoadBalancerListenerEndpoint {
    addresses: outputs.AlbLoadBalancerListenerEndpointAddress[];
    ports: number[];
}

export interface AlbLoadBalancerListenerEndpointAddress {
    externalIpv4Address?: outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv4Address;
    externalIpv6Address?: outputs.AlbLoadBalancerListenerEndpointAddressExternalIpv6Address;
    internalIpv4Address?: outputs.AlbLoadBalancerListenerEndpointAddressInternalIpv4Address;
}

export interface AlbLoadBalancerListenerEndpointAddressExternalIpv4Address {
    address: string;
}

export interface AlbLoadBalancerListenerEndpointAddressExternalIpv6Address {
    address: string;
}

export interface AlbLoadBalancerListenerEndpointAddressInternalIpv4Address {
    address: string;
    subnetId: string;
}

export interface AlbLoadBalancerListenerHttp {
    handler?: outputs.AlbLoadBalancerListenerHttpHandler;
    redirects?: outputs.AlbLoadBalancerListenerHttpRedirects;
}

export interface AlbLoadBalancerListenerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerHttpHandlerHttp2Options;
    httpRouterId?: string;
}

export interface AlbLoadBalancerListenerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerHttpRedirects {
    httpToHttps?: boolean;
}

export interface AlbLoadBalancerListenerStream {
    handler?: outputs.AlbLoadBalancerListenerStreamHandler;
}

export interface AlbLoadBalancerListenerStreamHandler {
    backendGroupId?: string;
}

export interface AlbLoadBalancerListenerTls {
    defaultHandler: outputs.AlbLoadBalancerListenerTlsDefaultHandler;
    sniHandlers?: outputs.AlbLoadBalancerListenerTlsSniHandler[];
}

export interface AlbLoadBalancerListenerTlsDefaultHandler {
    certificateIds: string[];
    httpHandler?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler;
    streamHandler?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options;
    httpRouterId?: string;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerTlsDefaultHandlerStreamHandler {
    backendGroupId?: string;
}

export interface AlbLoadBalancerListenerTlsSniHandler {
    handler: outputs.AlbLoadBalancerListenerTlsSniHandlerHandler;
    name: string;
    serverNames: string[];
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandler {
    certificateIds: string[];
    httpHandler?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler;
    streamHandler?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options?: outputs.AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options;
    httpRouterId?: string;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerHttpHandlerHttp2Options {
    maxConcurrentStreams?: number;
}

export interface AlbLoadBalancerListenerTlsSniHandlerHandlerStreamHandler {
    backendGroupId?: string;
}

export interface AlbTargetGroupTarget {
    ipAddress: string;
    privateIpv4Address?: boolean;
    subnetId?: string;
}

export interface AlbVirtualHostModifyRequestHeader {
    append?: string;
    name: string;
    remove?: boolean;
    replace?: string;
}

export interface AlbVirtualHostModifyResponseHeader {
    append?: string;
    name: string;
    remove?: boolean;
    replace?: string;
}

export interface AlbVirtualHostRoute {
    grpcRoute?: outputs.AlbVirtualHostRouteGrpcRoute;
    httpRoute?: outputs.AlbVirtualHostRouteHttpRoute;
    name?: string;
    routeOptions?: outputs.AlbVirtualHostRouteRouteOptions;
}

export interface AlbVirtualHostRouteGrpcRoute {
    grpcMatches?: outputs.AlbVirtualHostRouteGrpcRouteGrpcMatch[];
    grpcRouteAction?: outputs.AlbVirtualHostRouteGrpcRouteGrpcRouteAction;
    grpcStatusResponseAction?: outputs.AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcMatch {
    fqmn?: outputs.AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcMatchFqmn {
    exact?: string;
    prefix?: string;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcRouteAction {
    autoHostRewrite?: boolean;
    backendGroupId: string;
    hostRewrite?: string;
    idleTimeout?: string;
    maxTimeout?: string;
}

export interface AlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction {
    status?: string;
}

export interface AlbVirtualHostRouteHttpRoute {
    directResponseAction?: outputs.AlbVirtualHostRouteHttpRouteDirectResponseAction;
    httpMatches?: outputs.AlbVirtualHostRouteHttpRouteHttpMatch[];
    httpRouteAction?: outputs.AlbVirtualHostRouteHttpRouteHttpRouteAction;
    redirectAction?: outputs.AlbVirtualHostRouteHttpRouteRedirectAction;
}

export interface AlbVirtualHostRouteHttpRouteDirectResponseAction {
    body?: string;
    status?: number;
}

export interface AlbVirtualHostRouteHttpRouteHttpMatch {
    httpMethods?: string[];
    path?: outputs.AlbVirtualHostRouteHttpRouteHttpMatchPath;
}

export interface AlbVirtualHostRouteHttpRouteHttpMatchPath {
    exact?: string;
    prefix?: string;
}

export interface AlbVirtualHostRouteHttpRouteHttpRouteAction {
    autoHostRewrite?: boolean;
    backendGroupId: string;
    hostRewrite?: string;
    idleTimeout?: string;
    prefixRewrite?: string;
    timeout?: string;
    upgradeTypes?: string[];
}

export interface AlbVirtualHostRouteHttpRouteRedirectAction {
    removeQuery?: boolean;
    replaceHost?: string;
    replacePath?: string;
    replacePort?: number;
    replacePrefix?: string;
    replaceScheme?: string;
    responseCode?: string;
}

export interface AlbVirtualHostRouteOptions {
    rbac?: outputs.AlbVirtualHostRouteOptionsRbac;
}

export interface AlbVirtualHostRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbVirtualHostRouteOptionsRbacPrincipal[];
}

export interface AlbVirtualHostRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbVirtualHostRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
}

export interface AlbVirtualHostRouteRouteOptions {
    rbac?: outputs.AlbVirtualHostRouteRouteOptionsRbac;
}

export interface AlbVirtualHostRouteRouteOptionsRbac {
    action?: string;
    principals: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipal[];
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipal {
    andPrincipals: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal[];
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipal {
    any?: boolean;
    header?: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader;
    remoteIp?: string;
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeader {
    name: string;
    value?: outputs.AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue;
}

export interface AlbVirtualHostRouteRouteOptionsRbacPrincipalAndPrincipalHeaderValue {
    exact?: string;
    prefix?: string;
}

export interface CdnOriginGroupOrigin {
    backup?: boolean;
    enabled?: boolean;
    originGroupId: number;
    source: string;
}

export interface CdnResourceOptions {
    allowedHttpMethods: string[];
    browserCacheSettings: number;
    cacheHttpHeaders: string[];
    cors: string[];
    customHostHeader: string;
    customServerName: string;
    disableCache: boolean;
    disableProxyForceRanges: boolean;
    edgeCacheSettings: number;
    fetchedCompressed: boolean;
    forwardHostHeader: boolean;
    gzipOn: boolean;
    ignoreCookie: boolean;
    ignoreQueryParams: boolean;
    proxyCacheMethodsSet: boolean;
    queryParamsBlacklists: string[];
    queryParamsWhitelists: string[];
    redirectHttpToHttps: boolean;
    redirectHttpsToHttp: boolean;
    slice: boolean;
    staticRequestHeaders: string[];
    staticResponseHeaders: {[key: string]: string};
}

export interface CdnResourceSslCertificate {
    certificateManagerId?: string;
    status: string;
    type: string;
}

export interface ComputeDiskDiskPlacementPolicy {
    diskPlacementGroupId: string;
}

export interface ComputeInstanceBootDisk {
    autoDelete?: boolean;
    deviceName: string;
    diskId: string;
    initializeParams: outputs.ComputeInstanceBootDiskInitializeParams;
    mode: string;
}

export interface ComputeInstanceBootDiskInitializeParams {
    blockSize: number;
    description: string;
    imageId: string;
    name: string;
    size: number;
    snapshotId: string;
    type?: string;
}

export interface ComputeInstanceGroupAllocationPolicy {
    zones: string[];
}

export interface ComputeInstanceGroupApplicationLoadBalancer {
    maxOpeningTrafficDuration?: number;
    statusMessage: string;
    targetGroupDescription?: string;
    targetGroupId: string;
    targetGroupLabels?: {[key: string]: string};
    targetGroupName?: string;
}

export interface ComputeInstanceGroupDeployPolicy {
    maxCreating?: number;
    maxDeleting?: number;
    maxExpansion: number;
    maxUnavailable: number;
    startupDuration?: number;
    strategy: string;
}

export interface ComputeInstanceGroupHealthCheck {
    healthyThreshold?: number;
    httpOptions?: outputs.ComputeInstanceGroupHealthCheckHttpOption[];
    interval?: number;
    tcpOptions: outputs.ComputeInstanceGroupHealthCheckTcpOptions;
    timeout?: number;
    unhealthyThreshold?: number;
}

export interface ComputeInstanceGroupHealthCheckHttpOption {
    path: string;
    port: number;
}

export interface ComputeInstanceGroupHealthCheckTcpOptions {
    port: number;
}

export interface ComputeInstanceGroupInstance {
    fqdn: string;
    instanceId: string;
    name: string;
    networkInterfaces: outputs.ComputeInstanceGroupInstanceNetworkInterface[];
    status: string;
    statusChangedAt: string;
    statusMessage: string;
    zoneId: string;
}

export interface ComputeInstanceGroupInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat: boolean;
    natIpAddress: string;
    natIpVersion: string;
    subnetId: string;
}

export interface ComputeInstanceGroupInstanceTemplate {
    bootDisk: outputs.ComputeInstanceGroupInstanceTemplateBootDisk;
    description?: string;
    hostname?: string;
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    name?: string;
    networkInterfaces: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterface[];
    networkSettings?: outputs.ComputeInstanceGroupInstanceTemplateNetworkSetting[];
    placementPolicy?: outputs.ComputeInstanceGroupInstanceTemplatePlacementPolicy;
    platformId?: string;
    resources: outputs.ComputeInstanceGroupInstanceTemplateResources;
    schedulingPolicy: outputs.ComputeInstanceGroupInstanceTemplateSchedulingPolicy;
    secondaryDisks?: outputs.ComputeInstanceGroupInstanceTemplateSecondaryDisk[];
    serviceAccountId?: string;
}

export interface ComputeInstanceGroupInstanceTemplateBootDisk {
    deviceName: string;
    diskId?: string;
    initializeParams?: outputs.ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams;
    mode?: string;
}

export interface ComputeInstanceGroupInstanceTemplateBootDiskInitializeParams {
    description?: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type?: string;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterface {
    dnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord[];
    ipAddress: string;
    ipv4?: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    natDnsRecords?: outputs.ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord[];
    natIpAddress?: string;
    networkId?: string;
    securityGroupIds?: string[];
    subnetIds?: string[];
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr: boolean;
    ttl?: number;
}

export interface ComputeInstanceGroupInstanceTemplateNetworkSetting {
    type?: string;
}

export interface ComputeInstanceGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface ComputeInstanceGroupInstanceTemplateResources {
    coreFraction?: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface ComputeInstanceGroupInstanceTemplateSchedulingPolicy {
    preemptible?: boolean;
}

export interface ComputeInstanceGroupInstanceTemplateSecondaryDisk {
    deviceName?: string;
    diskId?: string;
    initializeParams?: outputs.ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams;
    mode?: string;
}

export interface ComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParams {
    description?: string;
    imageId?: string;
    size?: number;
    snapshotId?: string;
    type?: string;
}

export interface ComputeInstanceGroupLoadBalancer {
    maxOpeningTrafficDuration?: number;
    statusMessage: string;
    targetGroupDescription?: string;
    targetGroupId: string;
    targetGroupLabels?: {[key: string]: string};
    targetGroupName?: string;
}

export interface ComputeInstanceGroupScalePolicy {
    autoScale?: outputs.ComputeInstanceGroupScalePolicyAutoScale;
    fixedScale?: outputs.ComputeInstanceGroupScalePolicyFixedScale;
    testAutoScale?: outputs.ComputeInstanceGroupScalePolicyTestAutoScale;
}

export interface ComputeInstanceGroupScalePolicyAutoScale {
    cpuUtilizationTarget?: number;
    customRules?: outputs.ComputeInstanceGroupScalePolicyAutoScaleCustomRule[];
    initialSize: number;
    maxSize?: number;
    measurementDuration: number;
    minZoneSize?: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface ComputeInstanceGroupScalePolicyAutoScaleCustomRule {
    folderId?: string;
    labels?: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service?: string;
    target: number;
}

export interface ComputeInstanceGroupScalePolicyFixedScale {
    size: number;
}

export interface ComputeInstanceGroupScalePolicyTestAutoScale {
    cpuUtilizationTarget?: number;
    customRules?: outputs.ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule[];
    initialSize: number;
    maxSize?: number;
    measurementDuration: number;
    minZoneSize?: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface ComputeInstanceGroupScalePolicyTestAutoScaleCustomRule {
    folderId?: string;
    labels?: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service?: string;
    target: number;
}

export interface ComputeInstanceLocalDisk {
    deviceName: string;
    sizeBytes: number;
}

export interface ComputeInstanceNetworkInterface {
    dnsRecords?: outputs.ComputeInstanceNetworkInterfaceDnsRecord[];
    index: number;
    ipAddress: string;
    ipv4?: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords?: outputs.ComputeInstanceNetworkInterfaceIpv6DnsRecord[];
    macAddress: string;
    nat: boolean;
    natDnsRecords?: outputs.ComputeInstanceNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface ComputeInstanceNetworkInterfaceDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstanceNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstanceNetworkInterfaceNatDnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface ComputeInstancePlacementPolicy {
    hostAffinityRules: outputs.ComputeInstancePlacementPolicyHostAffinityRule[];
    placementGroupId?: string;
}

export interface ComputeInstancePlacementPolicyHostAffinityRule {
    key: string;
    op: string;
    values: string[];
}

export interface ComputeInstanceResources {
    coreFraction?: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface ComputeInstanceSchedulingPolicy {
    preemptible?: boolean;
}

export interface ComputeInstanceSecondaryDisk {
    autoDelete?: boolean;
    deviceName: string;
    diskId: string;
    mode?: string;
}

export interface DataprocClusterClusterConfig {
    hadoop?: outputs.DataprocClusterClusterConfigHadoop;
    subclusterSpecs: outputs.DataprocClusterClusterConfigSubclusterSpec[];
    versionId: string;
}

export interface DataprocClusterClusterConfigHadoop {
    properties?: {[key: string]: string};
    services?: string[];
    sshPublicKeys?: string[];
}

export interface DataprocClusterClusterConfigSubclusterSpec {
    assignPublicIp?: boolean;
    autoscalingConfig?: outputs.DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig;
    hostsCount: number;
    id: string;
    name: string;
    resources: outputs.DataprocClusterClusterConfigSubclusterSpecResources;
    role: string;
    subnetId: string;
}

export interface DataprocClusterClusterConfigSubclusterSpecAutoscalingConfig {
    cpuUtilizationTarget?: number;
    decommissionTimeout?: number;
    maxHostsCount: number;
    measurementDuration?: number;
    preemptible?: boolean;
    stabilizationDuration?: number;
    warmupDuration?: number;
}

export interface DataprocClusterClusterConfigSubclusterSpecResources {
    diskSize: number;
    diskTypeId?: string;
    resourcePresetId: string;
}

export interface DatatransferEndpointSettings {
    clickhouseSource?: outputs.DatatransferEndpointSettingsClickhouseSource;
    clickhouseTarget?: outputs.DatatransferEndpointSettingsClickhouseTarget;
    mongoSource?: outputs.DatatransferEndpointSettingsMongoSource;
    mongoTarget?: outputs.DatatransferEndpointSettingsMongoTarget;
    mysqlSource?: outputs.DatatransferEndpointSettingsMysqlSource;
    mysqlTarget?: outputs.DatatransferEndpointSettingsMysqlTarget;
    postgresSource?: outputs.DatatransferEndpointSettingsPostgresSource;
    postgresTarget?: outputs.DatatransferEndpointSettingsPostgresTarget;
}

export interface DatatransferEndpointSettingsClickhouseSource {
    connection: outputs.DatatransferEndpointSettingsClickhouseSourceConnection;
    excludeTables: string[];
    includeTables: string[];
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnection {
    connectionOptions: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptions {
    database: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise;
    password: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremise {
    httpPort: number;
    nativePort: number;
    shards: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard[];
    tlsMode: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseShard {
    hosts: string[];
    name: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsClickhouseSourceConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsClickhouseTarget {
    altNames: outputs.DatatransferEndpointSettingsClickhouseTargetAltName[];
    cleanupPolicy: string;
    clickhouseClusterName: string;
    connection: outputs.DatatransferEndpointSettingsClickhouseTargetConnection;
    securityGroups: string[];
    sharding: outputs.DatatransferEndpointSettingsClickhouseTargetSharding;
    subnetId: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetAltName {
    fromName: string;
    toName: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnection {
    connectionOptions: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptions {
    database: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise;
    password: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremise {
    httpPort: number;
    nativePort: number;
    shards: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard[];
    tlsMode: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseShard {
    hosts: string[];
    name: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetSharding {
    columnValueHash?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash;
    transferId?: outputs.DatatransferEndpointSettingsClickhouseTargetShardingTransferId;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingColumnValueHash {
    columnName: string;
}

export interface DatatransferEndpointSettingsClickhouseTargetShardingTransferId {
}

export interface DatatransferEndpointSettingsMongoSource {
    collections: outputs.DatatransferEndpointSettingsMongoSourceCollection[];
    connection: outputs.DatatransferEndpointSettingsMongoSourceConnection;
    excludedCollections: outputs.DatatransferEndpointSettingsMongoSourceExcludedCollection[];
    secondaryPreferredMode: boolean;
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsMongoSourceCollection {
    collectionName: string;
    databaseName: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnection {
    connectionOptions: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptions {
    authSource: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise;
    password: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremise {
    hosts: string[];
    port: number;
    replicaSet: string;
    tlsMode: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMongoSourceConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMongoSourceExcludedCollection {
    collectionName: string;
    databaseName: string;
}

export interface DatatransferEndpointSettingsMongoTarget {
    cleanupPolicy: string;
    connection: outputs.DatatransferEndpointSettingsMongoTargetConnection;
    database: string;
    securityGroups: string[];
    subnetId: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnection {
    connectionOptions: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptions {
    authSource: string;
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise;
    password: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword;
    user: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremise {
    hosts: string[];
    port: number;
    replicaSet: string;
    tlsMode: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMongoTargetConnectionConnectionOptionsPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMysqlSource {
    connection: outputs.DatatransferEndpointSettingsMysqlSourceConnection;
    database: string;
    excludeTablesRegexes: string[];
    includeTablesRegexes: string[];
    objectTransferSettings: outputs.DatatransferEndpointSettingsMysqlSourceObjectTransferSettings;
    password: outputs.DatatransferEndpointSettingsMysqlSourcePassword;
    securityGroups: string[];
    serviceDatabase: string;
    timezone: string;
    user: string;
}

export interface DatatransferEndpointSettingsMysqlSourceConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremise;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMysqlSourceConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMysqlSourceObjectTransferSettings {
    routine: string;
    trigger: string;
    view: string;
}

export interface DatatransferEndpointSettingsMysqlSourcePassword {
    raw: string;
}

export interface DatatransferEndpointSettingsMysqlTarget {
    connection: outputs.DatatransferEndpointSettingsMysqlTargetConnection;
    database: string;
    password: outputs.DatatransferEndpointSettingsMysqlTargetPassword;
    securityGroups: string[];
    skipConstraintChecks: boolean;
    sqlMode: string;
    timezone: string;
    user: string;
}

export interface DatatransferEndpointSettingsMysqlTargetConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremise;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsMysqlTargetConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsMysqlTargetPassword {
    raw: string;
}

export interface DatatransferEndpointSettingsPostgresSource {
    connection: outputs.DatatransferEndpointSettingsPostgresSourceConnection;
    database: string;
    excludeTables: string[];
    includeTables: string[];
    objectTransferSettings: outputs.DatatransferEndpointSettingsPostgresSourceObjectTransferSettings;
    password: outputs.DatatransferEndpointSettingsPostgresSourcePassword;
    securityGroups: string[];
    serviceSchema: string;
    slotGigabyteLagLimit: number;
    user: string;
}

export interface DatatransferEndpointSettingsPostgresSourceConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremise;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsPostgresSourceConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsPostgresSourceObjectTransferSettings {
    cast: string;
    collation: string;
    constraint: string;
    defaultValues: string;
    fkConstraint: string;
    function: string;
    index: string;
    materializedView: string;
    policy: string;
    primaryKey: string;
    rule: string;
    sequence: string;
    sequenceOwnedBy: string;
    table: string;
    trigger: string;
    type: string;
    view: string;
}

export interface DatatransferEndpointSettingsPostgresSourcePassword {
    raw: string;
}

export interface DatatransferEndpointSettingsPostgresTarget {
    connection: outputs.DatatransferEndpointSettingsPostgresTargetConnection;
    database: string;
    password: outputs.DatatransferEndpointSettingsPostgresTargetPassword;
    securityGroups: string[];
    user: string;
}

export interface DatatransferEndpointSettingsPostgresTargetConnection {
    mdbClusterId?: string;
    onPremise?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremise;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremise {
    hosts: string[];
    port: number;
    subnetId: string;
    tlsMode: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsMode {
    disabled?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled;
    enabled?: outputs.DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled;
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeDisabled {
}

export interface DatatransferEndpointSettingsPostgresTargetConnectionOnPremiseTlsModeEnabled {
    caCertificate: string;
}

export interface DatatransferEndpointSettingsPostgresTargetPassword {
    raw: string;
}

export interface FunctionContent {
    zipFilename: string;
}

export interface FunctionPackage {
    bucketName: string;
    objectName: string;
    sha256?: string;
}

export interface FunctionScalingPolicyPolicy {
    tag: string;
    zoneInstancesLimit?: number;
    zoneRequestsLimit?: number;
}

export interface FunctionSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface FunctionTriggerDlq {
    queueId: string;
    serviceAccountId: string;
}

export interface FunctionTriggerFunction {
    id: string;
    retryAttempts?: string;
    retryInterval?: string;
    serviceAccountId?: string;
    tag?: string;
}

export interface FunctionTriggerIot {
    deviceId?: string;
    registryId: string;
    topic?: string;
}

export interface FunctionTriggerLogGroup {
    batchCutoff: string;
    batchSize?: string;
    logGroupIds: string[];
}

export interface FunctionTriggerLogging {
    batchCutoff: string;
    batchSize?: string;
    groupId: string;
    levels: string[];
    resourceIds: string[];
    resourceTypes: string[];
}

export interface FunctionTriggerMessageQueue {
    batchCutoff: string;
    batchSize?: string;
    queueId: string;
    serviceAccountId: string;
    visibilityTimeout?: string;
}

export interface FunctionTriggerObjectStorage {
    bucketId: string;
    create?: boolean;
    delete?: boolean;
    prefix?: string;
    suffix?: string;
    update?: boolean;
}

export interface FunctionTriggerTimer {
    cronExpression: string;
}

export interface GetAlbBackendGroupGrpcBackend {
    healthcheck: outputs.GetAlbBackendGroupGrpcBackendHealthcheck;
    loadBalancingConfig: outputs.GetAlbBackendGroupGrpcBackendLoadBalancingConfig;
    name: string;
    port: number;
    targetGroupIds: string[];
    tls: outputs.GetAlbBackendGroupGrpcBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheck {
    grpcHealthcheck: outputs.GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck: outputs.GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck: outputs.GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupGrpcBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupGrpcBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupGrpcBackendTls {
    sni: string;
    validationContext: outputs.GetAlbBackendGroupGrpcBackendTlsValidationContext;
}

export interface GetAlbBackendGroupGrpcBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbBackendGroupHttpBackend {
    healthcheck: outputs.GetAlbBackendGroupHttpBackendHealthcheck;
    http2: boolean;
    loadBalancingConfig: outputs.GetAlbBackendGroupHttpBackendLoadBalancingConfig;
    name: string;
    port: number;
    storageBucket: string;
    targetGroupIds: string[];
    tls: outputs.GetAlbBackendGroupHttpBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupHttpBackendHealthcheck {
    grpcHealthcheck: outputs.GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck: outputs.GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck: outputs.GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupHttpBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupHttpBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupHttpBackendTls {
    sni: string;
    validationContext: outputs.GetAlbBackendGroupHttpBackendTlsValidationContext;
}

export interface GetAlbBackendGroupHttpBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbBackendGroupSessionAffinity {
    connection: outputs.GetAlbBackendGroupSessionAffinityConnection;
    cookie: outputs.GetAlbBackendGroupSessionAffinityCookie;
    header: outputs.GetAlbBackendGroupSessionAffinityHeader;
}

export interface GetAlbBackendGroupSessionAffinityConnection {
    sourceIp: boolean;
}

export interface GetAlbBackendGroupSessionAffinityCookie {
    name: string;
    ttl: string;
}

export interface GetAlbBackendGroupSessionAffinityHeader {
    headerName: string;
}

export interface GetAlbBackendGroupStreamBackend {
    enableProxyProtocol: boolean;
    healthcheck: outputs.GetAlbBackendGroupStreamBackendHealthcheck;
    loadBalancingConfig: outputs.GetAlbBackendGroupStreamBackendLoadBalancingConfig;
    name: string;
    port: number;
    targetGroupIds: string[];
    tls: outputs.GetAlbBackendGroupStreamBackendTls;
    weight: number;
}

export interface GetAlbBackendGroupStreamBackendHealthcheck {
    grpcHealthcheck: outputs.GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck;
    healthcheckPort: number;
    healthyThreshold: number;
    httpHealthcheck: outputs.GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheck;
    interval: string;
    intervalJitterPercent: number;
    streamHealthcheck: outputs.GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheck;
    timeout: string;
    unhealthyThreshold: number;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckGrpcHealthcheck {
    serviceName: string;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckHttpHealthcheck {
    host: string;
    http2: boolean;
    path: string;
}

export interface GetAlbBackendGroupStreamBackendHealthcheckStreamHealthcheck {
    receive: string;
    send: string;
}

export interface GetAlbBackendGroupStreamBackendLoadBalancingConfig {
    localityAwareRoutingPercent: number;
    mode: string;
    panicThreshold: number;
    strictLocality: boolean;
}

export interface GetAlbBackendGroupStreamBackendTls {
    sni: string;
    validationContext: outputs.GetAlbBackendGroupStreamBackendTlsValidationContext;
}

export interface GetAlbBackendGroupStreamBackendTlsValidationContext {
    trustedCaBytes: string;
    trustedCaId: string;
}

export interface GetAlbHttpRouterRouteOption {
    rbacs: outputs.GetAlbHttpRouterRouteOptionRbac[];
}

export interface GetAlbHttpRouterRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbHttpRouterRouteOptionRbacPrincipal[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbHttpRouterRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
}

export interface GetAlbLoadBalancerAllocationPolicy {
    locations: outputs.GetAlbLoadBalancerAllocationPolicyLocation[];
}

export interface GetAlbLoadBalancerAllocationPolicyLocation {
    disableTraffic: boolean;
    subnetId: string;
    zoneId: string;
}

export interface GetAlbLoadBalancerListener {
    endpoints: outputs.GetAlbLoadBalancerListenerEndpoint[];
    https?: outputs.GetAlbLoadBalancerListenerHttp[];
    name: string;
    stream?: outputs.GetAlbLoadBalancerListenerStream;
    tls?: outputs.GetAlbLoadBalancerListenerTl[];
}

export interface GetAlbLoadBalancerListenerEndpoint {
    addresses: outputs.GetAlbLoadBalancerListenerEndpointAddress[];
    ports: number[];
}

export interface GetAlbLoadBalancerListenerEndpointAddress {
    externalIpv4Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv4Address[];
    externalIpv6Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressExternalIpv6Address[];
    internalIpv4Addresses: outputs.GetAlbLoadBalancerListenerEndpointAddressInternalIpv4Address[];
}

export interface GetAlbLoadBalancerListenerEndpointAddressExternalIpv4Address {
    address: string;
}

export interface GetAlbLoadBalancerListenerEndpointAddressExternalIpv6Address {
    address: string;
}

export interface GetAlbLoadBalancerListenerEndpointAddressInternalIpv4Address {
    address: string;
    subnetId: string;
}

export interface GetAlbLoadBalancerListenerHttp {
    handlers?: outputs.GetAlbLoadBalancerListenerHttpHandler[];
    redirects?: outputs.GetAlbLoadBalancerListenerHttpRedirect[];
}

export interface GetAlbLoadBalancerListenerHttpHandler {
    allowHttp10?: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerHttpHandlerHttp2Option[];
    httpRouterId: string;
}

export interface GetAlbLoadBalancerListenerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerHttpRedirect {
    httpToHttps: boolean;
}

export interface GetAlbLoadBalancerListenerStream {
    handlers?: outputs.GetAlbLoadBalancerListenerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbLoadBalancerListenerTl {
    defaultHandlers: outputs.GetAlbLoadBalancerListenerTlDefaultHandler[];
    sniHandlers: outputs.GetAlbLoadBalancerListenerTlSniHandler[];
}

export interface GetAlbLoadBalancerListenerTlDefaultHandler {
    certificateIds: string[];
    httpHandlers?: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandler[];
    streamHandlers?: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2Option[];
    httpRouterId: string;
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerTlDefaultHandlerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbLoadBalancerListenerTlSniHandler {
    handlers: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandler[];
    name: string;
    serverNames: string[];
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandler {
    certificateIds: string[];
    httpHandlers?: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandler[];
    streamHandlers?: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandler[];
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandler {
    allowHttp10?: boolean;
    http2Options: outputs.GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2Option[];
    httpRouterId: string;
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerHttpHandlerHttp2Option {
    maxConcurrentStreams: number;
}

export interface GetAlbLoadBalancerListenerTlSniHandlerHandlerStreamHandler {
    backendGroupId: string;
}

export interface GetAlbTargetGroupTarget {
    ipAddress: string;
    privateIpv4Address?: boolean;
    subnetId?: string;
}

export interface GetAlbVirtualHostModifyRequestHeader {
    append: string;
    name: string;
    remove: boolean;
    replace: string;
}

export interface GetAlbVirtualHostModifyResponseHeader {
    append: string;
    name: string;
    remove: boolean;
    replace: string;
}

export interface GetAlbVirtualHostRoute {
    grpcRoutes: outputs.GetAlbVirtualHostRouteGrpcRoute[];
    httpRoutes: outputs.GetAlbVirtualHostRouteHttpRoute[];
    name: string;
    routeOptions: outputs.GetAlbVirtualHostRouteRouteOption[];
}

export interface GetAlbVirtualHostRouteGrpcRoute {
    grpcMatches: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatch[];
    grpcRouteActions: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcRouteAction[];
    grpcStatusResponseActions: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction[];
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcMatch {
    fqmns: outputs.GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmn[];
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcMatchFqmn {
    exact: string;
    prefix: string;
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcRouteAction {
    autoHostRewrite: boolean;
    backendGroupId: string;
    hostRewrite: string;
    idleTimeout: string;
    maxTimeout: string;
}

export interface GetAlbVirtualHostRouteGrpcRouteGrpcStatusResponseAction {
    status: string;
}

export interface GetAlbVirtualHostRouteHttpRoute {
    directResponseActions: outputs.GetAlbVirtualHostRouteHttpRouteDirectResponseAction[];
    httpMatches: outputs.GetAlbVirtualHostRouteHttpRouteHttpMatch[];
    httpRouteActions: outputs.GetAlbVirtualHostRouteHttpRouteHttpRouteAction[];
    redirectActions: outputs.GetAlbVirtualHostRouteHttpRouteRedirectAction[];
}

export interface GetAlbVirtualHostRouteHttpRouteDirectResponseAction {
    body: string;
    status: number;
}

export interface GetAlbVirtualHostRouteHttpRouteHttpMatch {
    httpMethods: string[];
    paths: outputs.GetAlbVirtualHostRouteHttpRouteHttpMatchPath[];
}

export interface GetAlbVirtualHostRouteHttpRouteHttpMatchPath {
    exact: string;
    prefix: string;
}

export interface GetAlbVirtualHostRouteHttpRouteHttpRouteAction {
    autoHostRewrite: boolean;
    backendGroupId: string;
    hostRewrite: string;
    idleTimeout: string;
    prefixRewrite: string;
    timeout: string;
    upgradeTypes: string[];
}

export interface GetAlbVirtualHostRouteHttpRouteRedirectAction {
    removeQuery: boolean;
    replaceHost: string;
    replacePath: string;
    replacePort: number;
    replacePrefix: string;
    replaceScheme: string;
    responseCode: string;
}

export interface GetAlbVirtualHostRouteOption {
    rbacs: outputs.GetAlbVirtualHostRouteOptionRbac[];
}

export interface GetAlbVirtualHostRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbVirtualHostRouteOptionRbacPrincipal[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbVirtualHostRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
}

export interface GetAlbVirtualHostRouteRouteOption {
    rbacs: outputs.GetAlbVirtualHostRouteRouteOptionRbac[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbac {
    action: string;
    principals: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipal[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipal {
    andPrincipals: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipal[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipal {
    any: boolean;
    headers: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeader[];
    remoteIp: string;
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeader {
    name: string;
    values: outputs.GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValue[];
}

export interface GetAlbVirtualHostRouteRouteOptionRbacPrincipalAndPrincipalHeaderValue {
    exact: string;
    prefix: string;
}

export interface GetCdnOriginGroupOrigin {
    backup?: boolean;
    enabled?: boolean;
    originGroupId: number;
    source: string;
}

export interface GetCdnResourceOptions {
    allowedHttpMethods: string[];
    browserCacheSettings: number;
    cacheHttpHeaders: string[];
    cors: string[];
    customHostHeader: string;
    customServerName: string;
    disableCache: boolean;
    disableProxyForceRanges: boolean;
    edgeCacheSettings: number;
    fetchedCompressed: boolean;
    forwardHostHeader: boolean;
    gzipOn: boolean;
    ignoreCookie: boolean;
    ignoreQueryParams: boolean;
    proxyCacheMethodsSet: boolean;
    queryParamsBlacklists: string[];
    queryParamsWhitelists: string[];
    redirectHttpToHttps: boolean;
    redirectHttpsToHttp: boolean;
    slice: boolean;
    staticRequestHeaders: string[];
    staticResponseHeaders: {[key: string]: string};
}

export interface GetCdnResourceSslCertificate {
    certificateManagerId?: string;
    status: string;
    type: string;
}

export interface GetComputeDiskDiskPlacementPolicy {
    diskPlacementGroupId: string;
}

export interface GetComputeInstanceBootDisk {
    autoDelete: boolean;
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceBootDiskInitializeParam[];
    mode: string;
}

export interface GetComputeInstanceBootDiskInitializeParam {
    blockSize: number;
    description: string;
    imageId: string;
    name: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceGroupAllocationPolicy {
    zones: string[];
}

export interface GetComputeInstanceGroupApplicationBalancerState {
    statusMessage: string;
    targetGroupId: string;
}

export interface GetComputeInstanceGroupApplicationLoadBalancer {
    maxOpeningTrafficDuration: number;
    statusMessage: string;
    targetGroupDescription: string;
    targetGroupId: string;
    targetGroupLabels: {[key: string]: string};
    targetGroupName: string;
}

export interface GetComputeInstanceGroupDeployPolicy {
    maxCreating: number;
    maxDeleting: number;
    maxExpansion: number;
    maxUnavailable: number;
    startupDuration: number;
    strategy: string;
}

export interface GetComputeInstanceGroupHealthCheck {
    healthyThreshold: number;
    httpOptions: outputs.GetComputeInstanceGroupHealthCheckHttpOption[];
    interval: number;
    tcpOptions: outputs.GetComputeInstanceGroupHealthCheckTcpOption[];
    timeout: number;
    unhealthyThreshold: number;
}

export interface GetComputeInstanceGroupHealthCheckHttpOption {
    path: string;
    port: number;
}

export interface GetComputeInstanceGroupHealthCheckTcpOption {
    port: number;
}

export interface GetComputeInstanceGroupInstance {
    fqdn: string;
    instanceId: string;
    name: string;
    networkInterfaces: outputs.GetComputeInstanceGroupInstanceNetworkInterface[];
    status: string;
    statusChangedAt: string;
    statusMessage: string;
    zoneId: string;
}

export interface GetComputeInstanceGroupInstanceNetworkInterface {
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    macAddress: string;
    nat: boolean;
    natIpAddress: string;
    natIpVersion: string;
    subnetId: string;
}

export interface GetComputeInstanceGroupInstanceTemplate {
    bootDisks: outputs.GetComputeInstanceGroupInstanceTemplateBootDisk[];
    description: string;
    hostname: string;
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    name: string;
    networkInterfaces: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterface[];
    networkSettings: outputs.GetComputeInstanceGroupInstanceTemplateNetworkSetting[];
    placementPolicy?: outputs.GetComputeInstanceGroupInstanceTemplatePlacementPolicy;
    platformId: string;
    resources: outputs.GetComputeInstanceGroupInstanceTemplateResource[];
    schedulingPolicies: outputs.GetComputeInstanceGroupInstanceTemplateSchedulingPolicy[];
    secondaryDisks: outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDisk[];
    serviceAccountId: string;
}

export interface GetComputeInstanceGroupInstanceTemplateBootDisk {
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParam[];
    mode: string;
}

export interface GetComputeInstanceGroupInstanceTemplateBootDiskInitializeParam {
    description: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterface {
    dnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord[];
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    natDnsRecords: outputs.GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    networkId: string;
    securityGroupIds: string[];
    subnetIds: string[];
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkInterfaceNatDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceGroupInstanceTemplateNetworkSetting {
    type: string;
}

export interface GetComputeInstanceGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface GetComputeInstanceGroupInstanceTemplateResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetComputeInstanceGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface GetComputeInstanceGroupInstanceTemplateSecondaryDisk {
    deviceName: string;
    diskId: string;
    initializeParams: outputs.GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParam[];
    mode: string;
}

export interface GetComputeInstanceGroupInstanceTemplateSecondaryDiskInitializeParam {
    description: string;
    imageId: string;
    size: number;
    snapshotId: string;
    type: string;
}

export interface GetComputeInstanceGroupLoadBalancer {
    maxOpeningTrafficDuration: number;
    statusMessage: string;
    targetGroupDescription: string;
    targetGroupId: string;
    targetGroupLabels: {[key: string]: string};
    targetGroupName: string;
}

export interface GetComputeInstanceGroupLoadBalancerState {
    statusMessage: string;
    targetGroupId: string;
}

export interface GetComputeInstanceGroupScalePolicy {
    autoScales: outputs.GetComputeInstanceGroupScalePolicyAutoScale[];
    fixedScales: outputs.GetComputeInstanceGroupScalePolicyFixedScale[];
    testAutoScales: outputs.GetComputeInstanceGroupScalePolicyTestAutoScale[];
}

export interface GetComputeInstanceGroupScalePolicyAutoScale {
    cpuUtilizationTarget: number;
    customRules: outputs.GetComputeInstanceGroupScalePolicyAutoScaleCustomRule[];
    initialSize: number;
    maxSize: number;
    measurementDuration: number;
    minZoneSize: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface GetComputeInstanceGroupScalePolicyAutoScaleCustomRule {
    folderId: string;
    labels: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service: string;
    target: number;
}

export interface GetComputeInstanceGroupScalePolicyFixedScale {
    size: number;
}

export interface GetComputeInstanceGroupScalePolicyTestAutoScale {
    cpuUtilizationTarget: number;
    customRules: outputs.GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRule[];
    initialSize: number;
    maxSize: number;
    measurementDuration: number;
    minZoneSize: number;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface GetComputeInstanceGroupScalePolicyTestAutoScaleCustomRule {
    folderId: string;
    labels: {[key: string]: string};
    metricName: string;
    metricType: string;
    ruleType: string;
    service: string;
    target: number;
}

export interface GetComputeInstanceLocalDisk {
    deviceName: string;
    sizeBytes: number;
}

export interface GetComputeInstanceNetworkInterface {
    dnsRecords: outputs.GetComputeInstanceNetworkInterfaceDnsRecord[];
    index: number;
    ipAddress: string;
    ipv4: boolean;
    ipv6: boolean;
    ipv6Address: string;
    ipv6DnsRecords: outputs.GetComputeInstanceNetworkInterfaceIpv6DnsRecord[];
    macAddress: string;
    nat: boolean;
    natDnsRecords: outputs.GetComputeInstanceNetworkInterfaceNatDnsRecord[];
    natIpAddress: string;
    natIpVersion: string;
    securityGroupIds: string[];
    subnetId: string;
}

export interface GetComputeInstanceNetworkInterfaceDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstanceNetworkInterfaceNatDnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetComputeInstancePlacementPolicy {
    hostAffinityRules: outputs.GetComputeInstancePlacementPolicyHostAffinityRule[];
    placementGroupId?: string;
}

export interface GetComputeInstancePlacementPolicyHostAffinityRule {
    key: string;
    op: string;
    values: string[];
}

export interface GetComputeInstanceResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetComputeInstanceSchedulingPolicy {
    preemptible?: boolean;
}

export interface GetComputeInstanceSecondaryDisk {
    autoDelete: boolean;
    deviceName: string;
    diskId: string;
    mode: string;
}

export interface GetDataprocClusterClusterConfig {
    hadoops: outputs.GetDataprocClusterClusterConfigHadoop[];
    subclusterSpecs: outputs.GetDataprocClusterClusterConfigSubclusterSpec[];
    versionId: string;
}

export interface GetDataprocClusterClusterConfigHadoop {
    properties: {[key: string]: string};
    services: string[];
    sshPublicKeys: string[];
}

export interface GetDataprocClusterClusterConfigSubclusterSpec {
    assignPublicIp: boolean;
    autoscalingConfigs: outputs.GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfig[];
    hostsCount: number;
    id: string;
    name: string;
    resources: outputs.GetDataprocClusterClusterConfigSubclusterSpecResource[];
    role: string;
    subnetId: string;
}

export interface GetDataprocClusterClusterConfigSubclusterSpecAutoscalingConfig {
    cpuUtilizationTarget: number;
    decommissionTimeout: number;
    maxHostsCount: number;
    measurementDuration: number;
    preemptible: boolean;
    stabilizationDuration: number;
    warmupDuration: number;
}

export interface GetDataprocClusterClusterConfigSubclusterSpecResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetFunctionScalingPolicyPolicy {
    tag: string;
    zoneInstancesLimit?: number;
    zoneRequestsLimit?: number;
}

export interface GetFunctionSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface GetFunctionTriggerDlq {
    queueId: string;
    serviceAccountId: string;
}

export interface GetFunctionTriggerFunction {
    id: string;
    retryAttempts: string;
    retryInterval: string;
    serviceAccountId: string;
    tag: string;
}

export interface GetFunctionTriggerIot {
    deviceId: string;
    registryId: string;
    topic: string;
}

export interface GetFunctionTriggerLogGroup {
    batchCutoff: string;
    batchSize: string;
    logGroupIds: string[];
}

export interface GetFunctionTriggerLogging {
    batchCutoff: string;
    batchSize: string;
    groupId: string;
    levels: string[];
    resourceIds: string[];
    resourceTypes: string[];
}

export interface GetFunctionTriggerMessageQueue {
    batchCutoff: string;
    batchSize: string;
    queueId: string;
    serviceAccountId: string;
    visibilityTimeout: string;
}

export interface GetFunctionTriggerObjectStorage {
    bucketId: string;
    create: boolean;
    delete: boolean;
    prefix: string;
    suffix: string;
    update: boolean;
}

export interface GetFunctionTriggerTimer {
    cronExpression: string;
}

export interface GetIamPolicyBinding {
    members: string[];
    role: string;
}

export interface GetKubernetesClusterKmsProvider {
    keyId: string;
}

export interface GetKubernetesClusterMaster {
    clusterCaCertificate: string;
    externalV4Address: string;
    externalV4Endpoint: string;
    internalV4Address: string;
    internalV4Endpoint: string;
    maintenancePolicies: outputs.GetKubernetesClusterMasterMaintenancePolicy[];
    publicIp: boolean;
    regionals: outputs.GetKubernetesClusterMasterRegional[];
    securityGroupIds: string[];
    version: string;
    versionInfos: outputs.GetKubernetesClusterMasterVersionInfo[];
    zonals: outputs.GetKubernetesClusterMasterZonal[];
}

export interface GetKubernetesClusterMasterMaintenancePolicy {
    autoUpgrade: boolean;
    maintenanceWindows: outputs.GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindow[];
}

export interface GetKubernetesClusterMasterMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface GetKubernetesClusterMasterRegional {
    region: string;
}

export interface GetKubernetesClusterMasterVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface GetKubernetesClusterMasterZonal {
    zone: string;
}

export interface GetKubernetesClusterNetworkImplementation {
    cilias: outputs.GetKubernetesClusterNetworkImplementationCilia[];
}

export interface GetKubernetesClusterNetworkImplementationCilia {
    routingMode: string;
}

export interface GetKubernetesNodeGroupAllocationPolicy {
    locations: outputs.GetKubernetesNodeGroupAllocationPolicyLocation[];
}

export interface GetKubernetesNodeGroupAllocationPolicyLocation {
    subnetId: string;
    zone: string;
}

export interface GetKubernetesNodeGroupDeployPolicy {
    maxExpansion: number;
    maxUnavailable: number;
}

export interface GetKubernetesNodeGroupInstanceTemplate {
    bootDisks: outputs.GetKubernetesNodeGroupInstanceTemplateBootDisk[];
    containerRuntime: outputs.GetKubernetesNodeGroupInstanceTemplateContainerRuntime;
    labels: {[key: string]: string};
    metadata: {[key: string]: string};
    name: string;
    nat: boolean;
    networkAccelerationType: string;
    networkInterfaces: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterface[];
    placementPolicies?: outputs.GetKubernetesNodeGroupInstanceTemplatePlacementPolicy[];
    platformId: string;
    resources: outputs.GetKubernetesNodeGroupInstanceTemplateResource[];
    schedulingPolicies: outputs.GetKubernetesNodeGroupInstanceTemplateSchedulingPolicy[];
}

export interface GetKubernetesNodeGroupInstanceTemplateBootDisk {
    size: number;
    type: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateContainerRuntime {
    type: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterface {
    ipv4: boolean;
    ipv4DnsRecords: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord[];
    ipv6: boolean;
    ipv6DnsRecords: outputs.GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    securityGroupIds: string[];
    subnetIds: string[];
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetKubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId: string;
    fqdn: string;
    ptr: boolean;
    ttl: number;
}

export interface GetKubernetesNodeGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface GetKubernetesNodeGroupInstanceTemplateResource {
    coreFraction: number;
    cores: number;
    gpus: number;
    memory: number;
}

export interface GetKubernetesNodeGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface GetKubernetesNodeGroupMaintenancePolicy {
    autoRepair: boolean;
    autoUpgrade: boolean;
    maintenanceWindows: outputs.GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindow[];
}

export interface GetKubernetesNodeGroupMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface GetKubernetesNodeGroupScalePolicy {
    autoScales: outputs.GetKubernetesNodeGroupScalePolicyAutoScale[];
    fixedScales: outputs.GetKubernetesNodeGroupScalePolicyFixedScale[];
}

export interface GetKubernetesNodeGroupScalePolicyAutoScale {
    initial: number;
    max: number;
    min: number;
}

export interface GetKubernetesNodeGroupScalePolicyFixedScale {
    size: number;
}

export interface GetKubernetesNodeGroupVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroup {
    healthchecks: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheck[];
    targetGroupId: string;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheck {
    healthyThreshold: number;
    httpOptions: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOption[];
    interval: number;
    name: string;
    tcpOptions: outputs.GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOption[];
    timeout: number;
    unhealthyThreshold: number;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOption {
    path: string;
    port: number;
}

export interface GetLbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOption {
    port: number;
}

export interface GetLbNetworkLoadBalancerListener {
    externalAddressSpecs: outputs.GetLbNetworkLoadBalancerListenerExternalAddressSpec[];
    internalAddressSpecs: outputs.GetLbNetworkLoadBalancerListenerInternalAddressSpec[];
    name: string;
    port: number;
    protocol: string;
    targetPort: number;
}

export interface GetLbNetworkLoadBalancerListenerExternalAddressSpec {
    address: string;
    ipVersion: string;
}

export interface GetLbNetworkLoadBalancerListenerInternalAddressSpec {
    address: string;
    ipVersion: string;
    subnetId: string;
}

export interface GetLbTargetGroupTarget {
    address: string;
    subnetId: string;
}

export interface GetMdbClickhouseClusterAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    metrika: boolean;
    serverless: boolean;
    webSql: boolean;
    yandexQuery: boolean;
}

export interface GetMdbClickhouseClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbClickhouseClusterClickhouse {
    config: outputs.GetMdbClickhouseClusterClickhouseConfig;
    resources: outputs.GetMdbClickhouseClusterClickhouseResource[];
}

export interface GetMdbClickhouseClusterClickhouseConfig {
    backgroundPoolSize?: number;
    backgroundSchedulePoolSize?: number;
    compressions?: outputs.GetMdbClickhouseClusterClickhouseConfigCompression[];
    geobaseUri?: string;
    graphiteRollups?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollup[];
    kafkaTopics?: outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopic[];
    kafkas: outputs.GetMdbClickhouseClusterClickhouseConfigKafka[];
    keepAliveTimeout?: number;
    logLevel?: string;
    markCacheSize?: number;
    maxConcurrentQueries?: number;
    maxConnections?: number;
    maxPartitionSizeToDrop?: number;
    maxTableSizeToDrop?: number;
    mergeTree: outputs.GetMdbClickhouseClusterClickhouseConfigMergeTree;
    metricLogEnabled?: boolean;
    metricLogRetentionSize?: number;
    metricLogRetentionTime?: number;
    partLogRetentionSize?: number;
    partLogRetentionTime?: number;
    queryLogRetentionSize?: number;
    queryLogRetentionTime?: number;
    queryThreadLogEnabled?: boolean;
    queryThreadLogRetentionSize?: number;
    queryThreadLogRetentionTime?: number;
    rabbitmq: outputs.GetMdbClickhouseClusterClickhouseConfigRabbitmq;
    textLogEnabled?: boolean;
    textLogLevel?: string;
    textLogRetentionSize?: number;
    textLogRetentionTime?: number;
    timezone?: string;
    traceLogEnabled?: boolean;
    traceLogRetentionSize?: number;
    traceLogRetentionTime?: number;
    uncompressedCacheSize?: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigCompression {
    method: string;
    minPartSize: number;
    minPartSizeRatio: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollup {
    name: string;
    patterns?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPattern[];
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPattern {
    function: string;
    regexp?: string;
    retentions?: outputs.GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention[];
}

export interface GetMdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention {
    age: number;
    precision: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafka {
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafkaTopic {
    name: string;
    settings?: outputs.GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettings;
}

export interface GetMdbClickhouseClusterClickhouseConfigKafkaTopicSettings {
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
}

export interface GetMdbClickhouseClusterClickhouseConfigMergeTree {
    maxBytesToMergeAtMinSpaceInPool?: number;
    maxReplicatedMergesInQueue?: number;
    numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge?: number;
    partsToDelayInsert?: number;
    partsToThrowInsert?: number;
    replicatedDeduplicationWindow?: number;
    replicatedDeduplicationWindowSeconds?: number;
}

export interface GetMdbClickhouseClusterClickhouseConfigRabbitmq {
    password?: string;
    username?: string;
}

export interface GetMdbClickhouseClusterClickhouseResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbClickhouseClusterCloudStorage {
    enabled: boolean;
}

export interface GetMdbClickhouseClusterDatabase {
    name: string;
}

export interface GetMdbClickhouseClusterFormatSchema {
    name: string;
    type: string;
    uri: string;
}

export interface GetMdbClickhouseClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    shardName: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface GetMdbClickhouseClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbClickhouseClusterMlModel {
    name: string;
    type: string;
    uri: string;
}

export interface GetMdbClickhouseClusterShardGroup {
    description: string;
    name: string;
    shardNames: string[];
}

export interface GetMdbClickhouseClusterUser {
    name: string;
    permissions: outputs.GetMdbClickhouseClusterUserPermission[];
    quotas: outputs.GetMdbClickhouseClusterUserQuota[];
    settings: outputs.GetMdbClickhouseClusterUserSettings;
}

export interface GetMdbClickhouseClusterUserPermission {
    databaseName: string;
}

export interface GetMdbClickhouseClusterUserQuota {
    errors: number;
    executionTime: number;
    intervalDuration: number;
    queries: number;
    readRows: number;
    resultRows: number;
}

export interface GetMdbClickhouseClusterUserSettings {
    addHttpCorsHeader: boolean;
    allowDdl: boolean;
    compile: boolean;
    compileExpressions: boolean;
    connectTimeout: number;
    countDistinctImplementation: string;
    distinctOverflowMode: string;
    distributedAggregationMemoryEfficient: boolean;
    distributedDdlTaskTimeout: number;
    distributedProductMode: string;
    emptyResultForAggregationByEmptySet: boolean;
    enableHttpCompression: boolean;
    fallbackToStaleReplicasForDistributedQueries: boolean;
    forceIndexByDate: boolean;
    forcePrimaryKey: boolean;
    groupByOverflowMode: string;
    groupByTwoLevelThreshold: number;
    groupByTwoLevelThresholdBytes: number;
    httpConnectionTimeout: number;
    httpHeadersProgressInterval: number;
    httpReceiveTimeout: number;
    httpSendTimeout: number;
    inputFormatDefaultsForOmittedFields: boolean;
    inputFormatValuesInterpretExpressions: boolean;
    insertQuorum: number;
    insertQuorumTimeout: number;
    joinOverflowMode: string;
    joinUseNulls: boolean;
    joinedSubqueryRequiresAlias: boolean;
    lowCardinalityAllowInNativeFormat: boolean;
    maxAstDepth: number;
    maxAstElements: number;
    maxBlockSize: number;
    maxBytesBeforeExternalGroupBy: number;
    maxBytesBeforeExternalSort: number;
    maxBytesInDistinct: number;
    maxBytesInJoin: number;
    maxBytesInSet: number;
    maxBytesToRead: number;
    maxBytesToSort: number;
    maxBytesToTransfer: number;
    maxColumnsToRead: number;
    maxExecutionTime: number;
    maxExpandedAstElements: number;
    maxInsertBlockSize: number;
    maxMemoryUsage: number;
    maxMemoryUsageForUser: number;
    maxNetworkBandwidth: number;
    maxNetworkBandwidthForUser: number;
    maxQuerySize: number;
    maxReplicaDelayForDistributedQueries: number;
    maxResultBytes: number;
    maxResultRows: number;
    maxRowsInDistinct: number;
    maxRowsInJoin: number;
    maxRowsInSet: number;
    maxRowsToGroupBy: number;
    maxRowsToRead: number;
    maxRowsToSort: number;
    maxRowsToTransfer: number;
    maxTemporaryColumns: number;
    maxTemporaryNonConstColumns: number;
    maxThreads: number;
    mergeTreeMaxBytesToUseCache: number;
    mergeTreeMaxRowsToUseCache: number;
    mergeTreeMinBytesForConcurrentRead: number;
    mergeTreeMinRowsForConcurrentRead: number;
    minBytesToUseDirectIo: number;
    minCountToCompile: number;
    minCountToCompileExpression: number;
    minExecutionSpeed: number;
    minExecutionSpeedBytes: number;
    minInsertBlockSizeBytes: number;
    minInsertBlockSizeRows: number;
    outputFormatJsonQuote64bitIntegers: boolean;
    outputFormatJsonQuoteDenormals: boolean;
    priority: number;
    quotaMode: string;
    readOverflowMode: string;
    readonly: number;
    receiveTimeout: number;
    replicationAlterPartitionsSync: number;
    resultOverflowMode: string;
    selectSequentialConsistency: boolean;
    sendProgressInHttpHeaders: boolean;
    sendTimeout: number;
    setOverflowMode: string;
    skipUnavailableShards: boolean;
    sortOverflowMode: string;
    timeoutOverflowMode: string;
    transferOverflowMode: string;
    transformNullIn: boolean;
    useUncompressedCache: boolean;
}

export interface GetMdbClickhouseClusterZookeeper {
    resources: outputs.GetMdbClickhouseClusterZookeeperResource[];
}

export interface GetMdbClickhouseClusterZookeeperResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticSearchClusterConfig {
    adminPassword: string;
    dataNodes: outputs.GetMdbElasticSearchClusterConfigDataNode[];
    edition: string;
    masterNode: outputs.GetMdbElasticSearchClusterConfigMasterNode;
    plugins: string[];
    version: string;
}

export interface GetMdbElasticSearchClusterConfigDataNode {
    resources: outputs.GetMdbElasticSearchClusterConfigDataNodeResource[];
}

export interface GetMdbElasticSearchClusterConfigDataNodeResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticSearchClusterConfigMasterNode {
    resources: outputs.GetMdbElasticSearchClusterConfigMasterNodeResource[];
}

export interface GetMdbElasticSearchClusterConfigMasterNodeResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbElasticSearchClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    name: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface GetMdbElasticSearchClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbGreenplumClusterAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    webSql: boolean;
}

export interface GetMdbGreenplumClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbGreenplumClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbGreenplumClusterMasterHost {
    assignPublicIp: boolean;
    fqdn: string;
}

export interface GetMdbGreenplumClusterMasterSubcluster {
    resources: outputs.GetMdbGreenplumClusterMasterSubclusterResource[];
}

export interface GetMdbGreenplumClusterMasterSubclusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbGreenplumClusterPoolerConfig {
    poolClientIdleTimeout?: number;
    poolSize?: number;
    poolingMode?: string;
}

export interface GetMdbGreenplumClusterSegmentHost {
    fqdn: string;
}

export interface GetMdbGreenplumClusterSegmentSubcluster {
    resources: outputs.GetMdbGreenplumClusterSegmentSubclusterResource[];
}

export interface GetMdbGreenplumClusterSegmentSubclusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterAccess {
    dataTransfer: boolean;
}

export interface GetMdbKafkaClusterConfig {
    access: outputs.GetMdbKafkaClusterConfigAccess;
    assignPublicIp?: boolean;
    brokersCount?: number;
    kafka: outputs.GetMdbKafkaClusterConfigKafka;
    schemaRegistry?: boolean;
    unmanagedTopics?: boolean;
    version: string;
    zones: string[];
    zookeeper: outputs.GetMdbKafkaClusterConfigZookeeper;
}

export interface GetMdbKafkaClusterConfigAccess {
    dataTransfer?: boolean;
}

export interface GetMdbKafkaClusterConfigKafka {
    kafkaConfig?: outputs.GetMdbKafkaClusterConfigKafkaKafkaConfig;
    resources: outputs.GetMdbKafkaClusterConfigKafkaResources;
}

export interface GetMdbKafkaClusterConfigKafkaKafkaConfig {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logFlushSchedulerIntervalMs?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMinutes?: string;
    logRetentionMs?: string;
    logSegmentBytes?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    replicaFetchMaxBytes?: string;
    socketReceiveBufferBytes?: string;
    socketSendBufferBytes?: string;
    sslCipherSuites: string[];
}

export interface GetMdbKafkaClusterConfigKafkaResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterConfigZookeeper {
    resources: outputs.GetMdbKafkaClusterConfigZookeeperResources;
}

export interface GetMdbKafkaClusterConfigZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbKafkaClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    subnetId: string;
    zoneId: string;
}

export interface GetMdbKafkaClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbKafkaClusterTopic {
    clusterId: string;
    name: string;
    partitions: number;
    replicationFactor: number;
    topicConfig?: outputs.GetMdbKafkaClusterTopicTopicConfig;
}

export interface GetMdbKafkaClusterTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface GetMdbKafkaClusterUser {
    name: string;
    password: string;
    permissions?: outputs.GetMdbKafkaClusterUserPermission[];
}

export interface GetMdbKafkaClusterUserPermission {
    role: string;
    topicName: string;
}

export interface GetMdbKafkaTopicTopicConfig {
    cleanupPolicy: string;
    compressionType: string;
    deleteRetentionMs: string;
    fileDeleteDelayMs: string;
    flushMessages: string;
    flushMs: string;
    maxMessageBytes: string;
    minCompactionLagMs: string;
    minInsyncReplicas: string;
    preallocate: boolean;
    retentionBytes: string;
    retentionMs: string;
    segmentBytes: string;
}

export interface GetMdbMongodbClusterClusterConfig {
    access: outputs.GetMdbMongodbClusterClusterConfigAccess;
    backupWindowStart: outputs.GetMdbMongodbClusterClusterConfigBackupWindowStart;
    featureCompatibilityVersion: string;
    mongod: outputs.GetMdbMongodbClusterClusterConfigMongod;
    version?: string;
}

export interface GetMdbMongodbClusterClusterConfigAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
}

export interface GetMdbMongodbClusterClusterConfigBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface GetMdbMongodbClusterClusterConfigMongod {
    auditLog: outputs.GetMdbMongodbClusterClusterConfigMongodAuditLog;
    security: outputs.GetMdbMongodbClusterClusterConfigMongodSecurity;
    setParameter: outputs.GetMdbMongodbClusterClusterConfigMongodSetParameter;
}

export interface GetMdbMongodbClusterClusterConfigMongodAuditLog {
    filter?: string;
    runtimeConfiguration?: boolean;
}

export interface GetMdbMongodbClusterClusterConfigMongodSecurity {
    enableEncryption?: boolean;
    kmip: outputs.GetMdbMongodbClusterClusterConfigMongodSecurityKmip;
}

export interface GetMdbMongodbClusterClusterConfigMongodSecurityKmip {
    clientCertificate?: string;
    keyIdentifier?: string;
    port?: number;
    serverCa?: string;
    serverName?: string;
}

export interface GetMdbMongodbClusterClusterConfigMongodSetParameter {
    auditAuthorizationSuccess?: boolean;
}

export interface GetMdbMongodbClusterDatabase {
    name?: string;
}

export interface GetMdbMongodbClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    shardName: string;
    subnetId?: string;
    type: string;
    zoneId?: string;
}

export interface GetMdbMongodbClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type?: string;
}

export interface GetMdbMongodbClusterResources {
    diskSize?: number;
    diskTypeId?: string;
    resourcePresetId?: string;
}

export interface GetMdbMongodbClusterUser {
    name?: string;
    password?: string;
    permissions: outputs.GetMdbMongodbClusterUserPermission[];
}

export interface GetMdbMongodbClusterUserPermission {
    databaseName?: string;
    roles?: string[];
}

export interface GetMdbMysqlClusterAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    webSql: boolean;
}

export interface GetMdbMysqlClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface GetMdbMysqlClusterDatabase {
    name: string;
}

export interface GetMdbMysqlClusterHost {
    assignPublicIp?: boolean;
    backupPriority?: number;
    fqdn: string;
    priority?: number;
    replicationSource: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbMysqlClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbMysqlClusterPerformanceDiagnostic {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface GetMdbMysqlClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbMysqlClusterUser {
    authenticationPlugin: string;
    connectionLimits: outputs.GetMdbMysqlClusterUserConnectionLimit[];
    globalPermissions: string[];
    name: string;
    password: string;
    permissions: outputs.GetMdbMysqlClusterUserPermission[];
}

export interface GetMdbMysqlClusterUserConnectionLimit {
    maxConnectionsPerHour: number;
    maxQuestionsPerHour: number;
    maxUpdatesPerHour: number;
    maxUserConnections: number;
}

export interface GetMdbMysqlClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface GetMdbPostgresqlClusterConfig {
    accesses: outputs.GetMdbPostgresqlClusterConfigAccess[];
    autofailover: boolean;
    backupRetainPeriodDays: number;
    backupWindowStarts: outputs.GetMdbPostgresqlClusterConfigBackupWindowStart[];
    performanceDiagnostics: outputs.GetMdbPostgresqlClusterConfigPerformanceDiagnostic[];
    poolerConfigs: outputs.GetMdbPostgresqlClusterConfigPoolerConfig[];
    postgresqlConfig: {[key: string]: string};
    resources: outputs.GetMdbPostgresqlClusterConfigResource[];
    version: string;
}

export interface GetMdbPostgresqlClusterConfigAccess {
    dataLens: boolean;
    dataTransfer: boolean;
    serverless: boolean;
    webSql: boolean;
}

export interface GetMdbPostgresqlClusterConfigBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbPostgresqlClusterConfigPerformanceDiagnostic {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface GetMdbPostgresqlClusterConfigPoolerConfig {
    poolDiscard: boolean;
    poolingMode: string;
}

export interface GetMdbPostgresqlClusterConfigResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbPostgresqlClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    priority: number;
    replicationSource: string;
    role: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbPostgresqlClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbRedisClusterConfig {
    clientOutputBufferLimitNormal: string;
    clientOutputBufferLimitPubsub: string;
    databases: number;
    maxmemoryPolicy: string;
    notifyKeyspaceEvents: string;
    slowlogLogSlowerThan: number;
    slowlogMaxLen: number;
    timeout: number;
    version: string;
}

export interface GetMdbRedisClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    replicaPriority?: number;
    shardName: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbRedisClusterMaintenanceWindow {
    day: string;
    hour: number;
    type: string;
}

export interface GetMdbRedisClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbSqlserverClusterBackupWindowStart {
    hours: number;
    minutes: number;
}

export interface GetMdbSqlserverClusterDatabase {
    name: string;
}

export interface GetMdbSqlserverClusterHost {
    assignPublicIp: boolean;
    fqdn: string;
    subnetId: string;
    zone: string;
}

export interface GetMdbSqlserverClusterResource {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface GetMdbSqlserverClusterUser {
    name: string;
    password: string;
    permissions: outputs.GetMdbSqlserverClusterUserPermission[];
}

export interface GetMdbSqlserverClusterUserPermission {
    databaseName: string;
    roles: string[];
}

export interface GetOrganizationmanagerSamlFederationSecuritySetting {
    encryptedAssertions: boolean;
}

export interface GetServerlessContainerImage {
    args: string[];
    commands: string[];
    digest: string;
    environment: {[key: string]: string};
    url: string;
    workDir: string;
}

export interface GetServerlessContainerSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface GetVpcAddressExternalIpv4Address {
    address: string;
    ddosProtectionProvider: string;
    outgoingSmtpCapability: string;
    zoneId: string;
}

export interface GetVpcRouteTableStaticRoute {
    destinationPrefix: string;
    gatewayId: string;
    nextHopAddress: string;
}

export interface GetVpcSecurityGroupEgress {
    description: string;
    fromPort: number;
    id: string;
    labels: {[key: string]: string};
    port: number;
    predefinedTarget: string;
    protocol: string;
    securityGroupId: string;
    toPort: number;
    v4CidrBlocks: string[];
    v6CidrBlocks: string[];
}

export interface GetVpcSecurityGroupIngress {
    description: string;
    fromPort: number;
    id: string;
    labels: {[key: string]: string};
    port: number;
    predefinedTarget: string;
    protocol: string;
    securityGroupId: string;
    toPort: number;
    v4CidrBlocks: string[];
    v6CidrBlocks: string[];
}

export interface GetVpcSubnetDhcpOption {
    domainName: string;
    domainNameServers: string[];
    ntpServers: string[];
}

export interface GetYdbDatabaseDedicatedLocation {
    regions: outputs.GetYdbDatabaseDedicatedLocationRegion[];
    zones: outputs.GetYdbDatabaseDedicatedLocationZone[];
}

export interface GetYdbDatabaseDedicatedLocationRegion {
    id: string;
}

export interface GetYdbDatabaseDedicatedLocationZone {
    id: string;
}

export interface GetYdbDatabaseDedicatedScalePolicy {
    fixedScales: outputs.GetYdbDatabaseDedicatedScalePolicyFixedScale[];
}

export interface GetYdbDatabaseDedicatedScalePolicyFixedScale {
    size: number;
}

export interface GetYdbDatabaseDedicatedStorageConfig {
    groupCount: number;
    storageTypeId: string;
}

export interface KubernetesClusterKmsProvider {
    keyId?: string;
}

export interface KubernetesClusterMaster {
    clusterCaCertificate: string;
    externalV4Address: string;
    externalV4Endpoint: string;
    internalV4Address: string;
    internalV4Endpoint: string;
    maintenancePolicy: outputs.KubernetesClusterMasterMaintenancePolicy;
    publicIp: boolean;
    regional: outputs.KubernetesClusterMasterRegional;
    securityGroupIds?: string[];
    version: string;
    versionInfos: outputs.KubernetesClusterMasterVersionInfo[];
    zonal: outputs.KubernetesClusterMasterZonal;
}

export interface KubernetesClusterMasterMaintenancePolicy {
    autoUpgrade: boolean;
    maintenanceWindows?: outputs.KubernetesClusterMasterMaintenancePolicyMaintenanceWindow[];
}

export interface KubernetesClusterMasterMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface KubernetesClusterMasterRegional {
    locations: outputs.KubernetesClusterMasterRegionalLocation[];
    region: string;
}

export interface KubernetesClusterMasterRegionalLocation {
    subnetId?: string;
    zone?: string;
}

export interface KubernetesClusterMasterVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface KubernetesClusterMasterZonal {
    subnetId?: string;
    zone: string;
}

export interface KubernetesClusterNetworkImplementation {
    cilium?: outputs.KubernetesClusterNetworkImplementationCilium;
}

export interface KubernetesClusterNetworkImplementationCilium {
}

export interface KubernetesNodeGroupAllocationPolicy {
    locations: outputs.KubernetesNodeGroupAllocationPolicyLocation[];
}

export interface KubernetesNodeGroupAllocationPolicyLocation {
    /**
     * @deprecated The 'subnet_id' field has been deprecated. Please use 'subnet_ids under network_interface' instead.
     */
    subnetId: string;
    zone: string;
}

export interface KubernetesNodeGroupDeployPolicy {
    maxExpansion: number;
    maxUnavailable: number;
}

export interface KubernetesNodeGroupInstanceTemplate {
    bootDisk: outputs.KubernetesNodeGroupInstanceTemplateBootDisk;
    containerRuntime: outputs.KubernetesNodeGroupInstanceTemplateContainerRuntime;
    labels?: {[key: string]: string};
    metadata: {[key: string]: string};
    name?: string;
    /**
     * @deprecated The 'nat' field has been deprecated. Please use 'nat under network_interface' instead.
     */
    nat: boolean;
    networkAccelerationType: string;
    networkInterfaces: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterface[];
    placementPolicy?: outputs.KubernetesNodeGroupInstanceTemplatePlacementPolicy;
    platformId: string;
    resources: outputs.KubernetesNodeGroupInstanceTemplateResources;
    schedulingPolicy: outputs.KubernetesNodeGroupInstanceTemplateSchedulingPolicy;
}

export interface KubernetesNodeGroupInstanceTemplateBootDisk {
    size: number;
    type: string;
}

export interface KubernetesNodeGroupInstanceTemplateContainerRuntime {
    type: string;
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterface {
    ipv4?: boolean;
    ipv4DnsRecords?: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord[];
    ipv6: boolean;
    ipv6DnsRecords?: outputs.KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord[];
    nat: boolean;
    securityGroupIds?: string[];
    subnetIds: string[];
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv4DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface KubernetesNodeGroupInstanceTemplateNetworkInterfaceIpv6DnsRecord {
    dnsZoneId?: string;
    fqdn: string;
    ptr?: boolean;
    ttl?: number;
}

export interface KubernetesNodeGroupInstanceTemplatePlacementPolicy {
    placementGroupId: string;
}

export interface KubernetesNodeGroupInstanceTemplateResources {
    coreFraction: number;
    cores: number;
    gpus?: number;
    memory: number;
}

export interface KubernetesNodeGroupInstanceTemplateSchedulingPolicy {
    preemptible: boolean;
}

export interface KubernetesNodeGroupMaintenancePolicy {
    autoRepair: boolean;
    autoUpgrade: boolean;
    maintenanceWindows?: outputs.KubernetesNodeGroupMaintenancePolicyMaintenanceWindow[];
}

export interface KubernetesNodeGroupMaintenancePolicyMaintenanceWindow {
    day: string;
    duration: string;
    startTime: string;
}

export interface KubernetesNodeGroupScalePolicy {
    autoScale?: outputs.KubernetesNodeGroupScalePolicyAutoScale;
    fixedScale?: outputs.KubernetesNodeGroupScalePolicyFixedScale;
}

export interface KubernetesNodeGroupScalePolicyAutoScale {
    initial: number;
    max: number;
    min: number;
}

export interface KubernetesNodeGroupScalePolicyFixedScale {
    size: number;
}

export interface KubernetesNodeGroupVersionInfo {
    currentVersion: string;
    newRevisionAvailable: boolean;
    newRevisionSummary: string;
    versionDeprecated: boolean;
}

export interface LbNetworkLoadBalancerAttachedTargetGroup {
    healthchecks: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheck[];
    targetGroupId: string;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheck {
    healthyThreshold?: number;
    httpOptions?: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions;
    interval?: number;
    name: string;
    tcpOptions?: outputs.LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions;
    timeout?: number;
    unhealthyThreshold?: number;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheckHttpOptions {
    path?: string;
    port: number;
}

export interface LbNetworkLoadBalancerAttachedTargetGroupHealthcheckTcpOptions {
    port: number;
}

export interface LbNetworkLoadBalancerListener {
    externalAddressSpec?: outputs.LbNetworkLoadBalancerListenerExternalAddressSpec;
    internalAddressSpec?: outputs.LbNetworkLoadBalancerListenerInternalAddressSpec;
    name: string;
    port: number;
    protocol: string;
    targetPort: number;
}

export interface LbNetworkLoadBalancerListenerExternalAddressSpec {
    address: string;
    ipVersion?: string;
}

export interface LbNetworkLoadBalancerListenerInternalAddressSpec {
    address: string;
    ipVersion?: string;
    subnetId: string;
}

export interface LbTargetGroupTarget {
    address: string;
    subnetId: string;
}

export interface MdbClickhouseClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    metrika?: boolean;
    serverless?: boolean;
    webSql?: boolean;
    yandexQuery?: boolean;
}

export interface MdbClickhouseClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbClickhouseClusterClickhouse {
    config: outputs.MdbClickhouseClusterClickhouseConfig;
    resources: outputs.MdbClickhouseClusterClickhouseResources;
}

export interface MdbClickhouseClusterClickhouseConfig {
    backgroundPoolSize: number;
    backgroundSchedulePoolSize: number;
    compressions?: outputs.MdbClickhouseClusterClickhouseConfigCompression[];
    geobaseUri: string;
    graphiteRollups?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollup[];
    kafka: outputs.MdbClickhouseClusterClickhouseConfigKafka;
    kafkaTopics?: outputs.MdbClickhouseClusterClickhouseConfigKafkaTopic[];
    keepAliveTimeout: number;
    logLevel: string;
    markCacheSize: number;
    maxConcurrentQueries: number;
    maxConnections: number;
    maxPartitionSizeToDrop: number;
    maxTableSizeToDrop: number;
    mergeTree: outputs.MdbClickhouseClusterClickhouseConfigMergeTree;
    metricLogEnabled: boolean;
    metricLogRetentionSize: number;
    metricLogRetentionTime: number;
    partLogRetentionSize: number;
    partLogRetentionTime: number;
    queryLogRetentionSize: number;
    queryLogRetentionTime: number;
    queryThreadLogEnabled: boolean;
    queryThreadLogRetentionSize: number;
    queryThreadLogRetentionTime: number;
    rabbitmq: outputs.MdbClickhouseClusterClickhouseConfigRabbitmq;
    textLogEnabled: boolean;
    textLogLevel: string;
    textLogRetentionSize: number;
    textLogRetentionTime: number;
    timezone: string;
    traceLogEnabled: boolean;
    traceLogRetentionSize: number;
    traceLogRetentionTime: number;
    uncompressedCacheSize: number;
}

export interface MdbClickhouseClusterClickhouseConfigCompression {
    method: string;
    minPartSize: number;
    minPartSizeRatio: number;
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollup {
    name: string;
    patterns?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern[];
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollupPattern {
    function: string;
    regexp: string;
    retentions?: outputs.MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention[];
}

export interface MdbClickhouseClusterClickhouseConfigGraphiteRollupPatternRetention {
    age: number;
    precision: number;
}

export interface MdbClickhouseClusterClickhouseConfigKafka {
    saslMechanism: string;
    saslPassword: string;
    saslUsername: string;
    securityProtocol: string;
}

export interface MdbClickhouseClusterClickhouseConfigKafkaTopic {
    name: string;
    settings?: outputs.MdbClickhouseClusterClickhouseConfigKafkaTopicSettings;
}

export interface MdbClickhouseClusterClickhouseConfigKafkaTopicSettings {
    saslMechanism?: string;
    saslPassword?: string;
    saslUsername?: string;
    securityProtocol?: string;
}

export interface MdbClickhouseClusterClickhouseConfigMergeTree {
    maxBytesToMergeAtMinSpaceInPool: number;
    maxReplicatedMergesInQueue: number;
    numberOfFreeEntriesInPoolToLowerMaxSizeOfMerge: number;
    partsToDelayInsert: number;
    partsToThrowInsert: number;
    replicatedDeduplicationWindow: number;
    replicatedDeduplicationWindowSeconds: number;
}

export interface MdbClickhouseClusterClickhouseConfigRabbitmq {
    password: string;
    username: string;
}

export interface MdbClickhouseClusterClickhouseResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbClickhouseClusterCloudStorage {
    enabled: boolean;
}

export interface MdbClickhouseClusterDatabase {
    name: string;
}

export interface MdbClickhouseClusterFormatSchema {
    name: string;
    type: string;
    uri: string;
}

export interface MdbClickhouseClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    shardName: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface MdbClickhouseClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbClickhouseClusterMlModel {
    name: string;
    type: string;
    uri: string;
}

export interface MdbClickhouseClusterShardGroup {
    description?: string;
    name: string;
    shardNames: string[];
}

export interface MdbClickhouseClusterUser {
    name: string;
    password: string;
    permissions: outputs.MdbClickhouseClusterUserPermission[];
    quotas: outputs.MdbClickhouseClusterUserQuota[];
    settings: outputs.MdbClickhouseClusterUserSettings;
}

export interface MdbClickhouseClusterUserPermission {
    databaseName: string;
}

export interface MdbClickhouseClusterUserQuota {
    errors: number;
    executionTime: number;
    intervalDuration: number;
    queries: number;
    readRows: number;
    resultRows: number;
}

export interface MdbClickhouseClusterUserSettings {
    addHttpCorsHeader: boolean;
    allowDdl: boolean;
    compile: boolean;
    compileExpressions: boolean;
    connectTimeout: number;
    countDistinctImplementation: string;
    distinctOverflowMode: string;
    distributedAggregationMemoryEfficient: boolean;
    distributedDdlTaskTimeout: number;
    distributedProductMode: string;
    emptyResultForAggregationByEmptySet: boolean;
    enableHttpCompression: boolean;
    fallbackToStaleReplicasForDistributedQueries: boolean;
    forceIndexByDate: boolean;
    forcePrimaryKey: boolean;
    groupByOverflowMode: string;
    groupByTwoLevelThreshold: number;
    groupByTwoLevelThresholdBytes: number;
    httpConnectionTimeout: number;
    httpHeadersProgressInterval: number;
    httpReceiveTimeout: number;
    httpSendTimeout: number;
    inputFormatDefaultsForOmittedFields: boolean;
    inputFormatValuesInterpretExpressions: boolean;
    insertQuorum: number;
    insertQuorumTimeout: number;
    joinOverflowMode: string;
    joinUseNulls: boolean;
    joinedSubqueryRequiresAlias: boolean;
    lowCardinalityAllowInNativeFormat: boolean;
    maxAstDepth: number;
    maxAstElements: number;
    maxBlockSize: number;
    maxBytesBeforeExternalGroupBy: number;
    maxBytesBeforeExternalSort: number;
    maxBytesInDistinct: number;
    maxBytesInJoin: number;
    maxBytesInSet: number;
    maxBytesToRead: number;
    maxBytesToSort: number;
    maxBytesToTransfer: number;
    maxColumnsToRead: number;
    maxExecutionTime: number;
    maxExpandedAstElements: number;
    maxInsertBlockSize: number;
    maxMemoryUsage: number;
    maxMemoryUsageForUser: number;
    maxNetworkBandwidth: number;
    maxNetworkBandwidthForUser: number;
    maxQuerySize: number;
    maxReplicaDelayForDistributedQueries: number;
    maxResultBytes: number;
    maxResultRows: number;
    maxRowsInDistinct: number;
    maxRowsInJoin: number;
    maxRowsInSet: number;
    maxRowsToGroupBy: number;
    maxRowsToRead: number;
    maxRowsToSort: number;
    maxRowsToTransfer: number;
    maxTemporaryColumns: number;
    maxTemporaryNonConstColumns: number;
    maxThreads: number;
    mergeTreeMaxBytesToUseCache: number;
    mergeTreeMaxRowsToUseCache: number;
    mergeTreeMinBytesForConcurrentRead: number;
    mergeTreeMinRowsForConcurrentRead: number;
    minBytesToUseDirectIo: number;
    minCountToCompile: number;
    minCountToCompileExpression: number;
    minExecutionSpeed: number;
    minExecutionSpeedBytes: number;
    minInsertBlockSizeBytes: number;
    minInsertBlockSizeRows: number;
    outputFormatJsonQuote64bitIntegers: boolean;
    outputFormatJsonQuoteDenormals: boolean;
    priority: number;
    quotaMode: string;
    readOverflowMode: string;
    readonly: number;
    receiveTimeout: number;
    replicationAlterPartitionsSync: number;
    resultOverflowMode: string;
    selectSequentialConsistency: boolean;
    sendProgressInHttpHeaders: boolean;
    sendTimeout: number;
    setOverflowMode: string;
    skipUnavailableShards: boolean;
    sortOverflowMode: string;
    timeoutOverflowMode: string;
    transferOverflowMode: string;
    transformNullIn: boolean;
    useUncompressedCache: boolean;
}

export interface MdbClickhouseClusterZookeeper {
    resources: outputs.MdbClickhouseClusterZookeeperResources;
}

export interface MdbClickhouseClusterZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticSearchClusterConfig {
    adminPassword: string;
    dataNode: outputs.MdbElasticSearchClusterConfigDataNode;
    edition: string;
    masterNode?: outputs.MdbElasticSearchClusterConfigMasterNode;
    plugins?: string[];
    version: string;
}

export interface MdbElasticSearchClusterConfigDataNode {
    resources: outputs.MdbElasticSearchClusterConfigDataNodeResources;
}

export interface MdbElasticSearchClusterConfigDataNodeResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticSearchClusterConfigMasterNode {
    resources: outputs.MdbElasticSearchClusterConfigMasterNodeResources;
}

export interface MdbElasticSearchClusterConfigMasterNodeResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbElasticSearchClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    name: string;
    subnetId: string;
    type: string;
    zone: string;
}

export interface MdbElasticSearchClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbGreenplumClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    webSql?: boolean;
}

export interface MdbGreenplumClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbGreenplumClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbGreenplumClusterMasterHost {
    assignPublicIp: boolean;
    fqdn: string;
}

export interface MdbGreenplumClusterMasterSubcluster {
    resources: outputs.MdbGreenplumClusterMasterSubclusterResources;
}

export interface MdbGreenplumClusterMasterSubclusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbGreenplumClusterPoolerConfig {
    poolClientIdleTimeout?: number;
    poolSize?: number;
    poolingMode?: string;
}

export interface MdbGreenplumClusterSegmentHost {
    fqdn: string;
}

export interface MdbGreenplumClusterSegmentSubcluster {
    resources: outputs.MdbGreenplumClusterSegmentSubclusterResources;
}

export interface MdbGreenplumClusterSegmentSubclusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbKafkaClusterConfig {
    access: outputs.MdbKafkaClusterConfigAccess;
    assignPublicIp?: boolean;
    brokersCount?: number;
    kafka: outputs.MdbKafkaClusterConfigKafka;
    schemaRegistry?: boolean;
    unmanagedTopics?: boolean;
    version: string;
    zones: string[];
    zookeeper: outputs.MdbKafkaClusterConfigZookeeper;
}

export interface MdbKafkaClusterConfigAccess {
    dataTransfer?: boolean;
}

export interface MdbKafkaClusterConfigKafka {
    kafkaConfig?: outputs.MdbKafkaClusterConfigKafkaKafkaConfig;
    resources: outputs.MdbKafkaClusterConfigKafkaResources;
}

export interface MdbKafkaClusterConfigKafkaKafkaConfig {
    autoCreateTopicsEnable?: boolean;
    compressionType?: string;
    defaultReplicationFactor?: string;
    logFlushIntervalMessages?: string;
    logFlushIntervalMs?: string;
    logFlushSchedulerIntervalMs?: string;
    logPreallocate?: boolean;
    logRetentionBytes?: string;
    logRetentionHours?: string;
    logRetentionMinutes?: string;
    logRetentionMs?: string;
    logSegmentBytes?: string;
    messageMaxBytes?: string;
    numPartitions?: string;
    offsetsRetentionMinutes?: string;
    replicaFetchMaxBytes?: string;
    socketReceiveBufferBytes?: string;
    socketSendBufferBytes?: string;
    sslCipherSuites: string[];
}

export interface MdbKafkaClusterConfigKafkaResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbKafkaClusterConfigZookeeper {
    resources: outputs.MdbKafkaClusterConfigZookeeperResources;
}

export interface MdbKafkaClusterConfigZookeeperResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbKafkaClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    subnetId: string;
    zoneId: string;
}

export interface MdbKafkaClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbKafkaClusterTopic {
    name: string;
    partitions: number;
    replicationFactor: number;
    topicConfig?: outputs.MdbKafkaClusterTopicTopicConfig;
}

export interface MdbKafkaClusterTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface MdbKafkaClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbKafkaClusterUserPermission[];
}

export interface MdbKafkaClusterUserPermission {
    role: string;
    topicName: string;
}

export interface MdbKafkaTopicTopicConfig {
    cleanupPolicy?: string;
    compressionType?: string;
    deleteRetentionMs?: string;
    fileDeleteDelayMs?: string;
    flushMessages?: string;
    flushMs?: string;
    maxMessageBytes?: string;
    minCompactionLagMs?: string;
    minInsyncReplicas?: string;
    preallocate?: boolean;
    retentionBytes?: string;
    retentionMs?: string;
    segmentBytes?: string;
}

export interface MdbMongodbClusterClusterConfig {
    access: outputs.MdbMongodbClusterClusterConfigAccess;
    backupWindowStart: outputs.MdbMongodbClusterClusterConfigBackupWindowStart;
    featureCompatibilityVersion: string;
    mongod: outputs.MdbMongodbClusterClusterConfigMongod;
    version: string;
}

export interface MdbMongodbClusterClusterConfigAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
}

export interface MdbMongodbClusterClusterConfigBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbMongodbClusterClusterConfigMongod {
    auditLog: outputs.MdbMongodbClusterClusterConfigMongodAuditLog;
    security: outputs.MdbMongodbClusterClusterConfigMongodSecurity;
    setParameter: outputs.MdbMongodbClusterClusterConfigMongodSetParameter;
}

export interface MdbMongodbClusterClusterConfigMongodAuditLog {
    filter?: string;
    runtimeConfiguration?: boolean;
}

export interface MdbMongodbClusterClusterConfigMongodSecurity {
    enableEncryption?: boolean;
    kmip: outputs.MdbMongodbClusterClusterConfigMongodSecurityKmip;
}

export interface MdbMongodbClusterClusterConfigMongodSecurityKmip {
    clientCertificate?: string;
    keyIdentifier?: string;
    port?: number;
    serverCa?: string;
    serverName?: string;
}

export interface MdbMongodbClusterClusterConfigMongodSetParameter {
    auditAuthorizationSuccess?: boolean;
}

export interface MdbMongodbClusterDatabase {
    name: string;
}

export interface MdbMongodbClusterHost {
    assignPublicIp: boolean;
    health: string;
    name: string;
    role: string;
    shardName: string;
    subnetId: string;
    type: string;
    zoneId: string;
}

export interface MdbMongodbClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbMongodbClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMongodbClusterUser {
    name: string;
    password: string;
    permissions: outputs.MdbMongodbClusterUserPermission[];
}

export interface MdbMongodbClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbMysqlClusterAccess {
    dataLens?: boolean;
    dataTransfer?: boolean;
    webSql?: boolean;
}

export interface MdbMysqlClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbMysqlClusterDatabase {
    name: string;
}

export interface MdbMysqlClusterHost {
    assignPublicIp?: boolean;
    backupPriority?: number;
    fqdn: string;
    name?: string;
    priority?: number;
    replicationSource: string;
    replicationSourceName?: string;
    subnetId: string;
    zone: string;
}

export interface MdbMysqlClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbMysqlClusterPerformanceDiagnostics {
    enabled: boolean;
    sessionsSamplingInterval: number;
    statementsSamplingInterval: number;
}

export interface MdbMysqlClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbMysqlClusterRestore {
    backupId: string;
    time?: string;
}

export interface MdbMysqlClusterUser {
    authenticationPlugin: string;
    connectionLimits: outputs.MdbMysqlClusterUserConnectionLimits;
    globalPermissions: string[];
    name: string;
    password: string;
    permissions: outputs.MdbMysqlClusterUserPermission[];
}

export interface MdbMysqlClusterUserConnectionLimits {
    maxConnectionsPerHour?: number;
    maxQuestionsPerHour?: number;
    maxUpdatesPerHour?: number;
    maxUserConnections?: number;
}

export interface MdbMysqlClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface MdbRedisClusterConfig {
    clientOutputBufferLimitNormal: string;
    clientOutputBufferLimitPubsub: string;
    databases: number;
    maxmemoryPolicy: string;
    notifyKeyspaceEvents: string;
    password: string;
    slowlogLogSlowerThan: number;
    slowlogMaxLen: number;
    timeout: number;
    version: string;
}

export interface MdbRedisClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    replicaPriority?: number;
    shardName: string;
    subnetId: string;
    zone: string;
}

export interface MdbRedisClusterMaintenanceWindow {
    day?: string;
    hour?: number;
    type: string;
}

export interface MdbRedisClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbSqlServerClusterBackupWindowStart {
    hours?: number;
    minutes?: number;
}

export interface MdbSqlServerClusterDatabase {
    name: string;
}

export interface MdbSqlServerClusterHost {
    assignPublicIp?: boolean;
    fqdn: string;
    subnetId: string;
    zone: string;
}

export interface MdbSqlServerClusterResources {
    diskSize: number;
    diskTypeId: string;
    resourcePresetId: string;
}

export interface MdbSqlServerClusterUser {
    name: string;
    password: string;
    permissions?: outputs.MdbSqlServerClusterUserPermission[];
}

export interface MdbSqlServerClusterUserPermission {
    databaseName: string;
    roles?: string[];
}

export interface OrganizationmanagerSamlFederationSecuritySettings {
    encryptedAssertions: boolean;
}

export interface ServerlessContainerImage {
    args?: string[];
    commands?: string[];
    digest: string;
    environment?: {[key: string]: string};
    url: string;
    workDir?: string;
}

export interface ServerlessContainerSecret {
    environmentVariable: string;
    id: string;
    key: string;
    versionId: string;
}

export interface StorageBucketAnonymousAccessFlags {
    list?: boolean;
    read?: boolean;
}

export interface StorageBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface StorageBucketGrant {
    id?: string;
    permissions: string[];
    type: string;
    uri?: string;
}

export interface StorageBucketHttps {
    certificateId: string;
}

export interface StorageBucketLifecycleRule {
    abortIncompleteMultipartUploadDays?: number;
    enabled: boolean;
    expiration?: outputs.StorageBucketLifecycleRuleExpiration;
    id: string;
    noncurrentVersionExpiration?: outputs.StorageBucketLifecycleRuleNoncurrentVersionExpiration;
    noncurrentVersionTransitions?: outputs.StorageBucketLifecycleRuleNoncurrentVersionTransition[];
    prefix?: string;
    transitions?: outputs.StorageBucketLifecycleRuleTransition[];
}

export interface StorageBucketLifecycleRuleExpiration {
    date?: string;
    days?: number;
    expiredObjectDeleteMarker?: boolean;
}

export interface StorageBucketLifecycleRuleNoncurrentVersionExpiration {
    days?: number;
}

export interface StorageBucketLifecycleRuleNoncurrentVersionTransition {
    days?: number;
    storageClass: string;
}

export interface StorageBucketLifecycleRuleTransition {
    date?: string;
    days?: number;
    storageClass: string;
}

export interface StorageBucketLogging {
    targetBucket: string;
    targetPrefix?: string;
}

export interface StorageBucketServerSideEncryptionConfiguration {
    rule: outputs.StorageBucketServerSideEncryptionConfigurationRule;
}

export interface StorageBucketServerSideEncryptionConfigurationRule {
    applyServerSideEncryptionByDefault: outputs.StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
}

export interface StorageBucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
    kmsMasterKeyId: string;
    sseAlgorithm: string;
}

export interface StorageBucketVersioning {
    enabled?: boolean;
}

export interface StorageBucketWebsite {
    errorDocument?: string;
    indexDocument?: string;
    redirectAllRequestsTo?: string;
    routingRules?: string;
}

export interface VpcAddressExternalIpv4Address {
    address: string;
    ddosProtectionProvider: string;
    outgoingSmtpCapability: string;
    zoneId: string;
}

export interface VpcDefaultSecurityGroupEgress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcDefaultSecurityGroupIngress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcRouteTableStaticRoute {
    destinationPrefix?: string;
    gatewayId?: string;
    nextHopAddress?: string;
}

export interface VpcSecurityGroupEgress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcSecurityGroupIngress {
    description?: string;
    fromPort?: number;
    id: string;
    labels: {[key: string]: string};
    port?: number;
    predefinedTarget?: string;
    protocol: string;
    securityGroupId?: string;
    toPort?: number;
    v4CidrBlocks?: string[];
    v6CidrBlocks?: string[];
}

export interface VpcSubnetDhcpOptions {
    domainName?: string;
    domainNameServers?: string[];
    ntpServers?: string[];
}

export interface YdbDatabaseDedicatedLocation {
    region?: outputs.YdbDatabaseDedicatedLocationRegion;
}

export interface YdbDatabaseDedicatedLocationRegion {
    id: string;
}

export interface YdbDatabaseDedicatedScalePolicy {
    fixedScale: outputs.YdbDatabaseDedicatedScalePolicyFixedScale;
}

export interface YdbDatabaseDedicatedScalePolicyFixedScale {
    size: number;
}

export interface YdbDatabaseDedicatedStorageConfig {
    groupCount: number;
    storageTypeId: string;
}
